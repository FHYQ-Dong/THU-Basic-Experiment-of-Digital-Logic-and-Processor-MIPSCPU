\section{仿真、综合及实现}

\subsection{行为级仿真}
使用iverilog对CPU进行三次行为级仿真以验证设计的正确性。为方便仿真，通过 \lstinline|SIMULATION| 宏控制 \lstinline|InstMem| 条件编译。当进行仿真时，\lstinline|InstMem| 通过 \lstinline|$readmemh| 读取Mars转换对应汇编文件生成的机器码文件而非使用硬编码在 \lstinline|InstMem| 中的指令进行初始化，从而可以在仅修改仿真代码而不修改CPU设计代码的情况下进行仿真。

\subsubsection{算术指令和转发}
\label{subsubsec:sim-arithmetic-instructions}
本仿真（Listing \ref{code:sim-tb-CPU-inst-1-v}, \ref{code:sim-tb-CPU-inst-1-asm}, \ref{code:sim-tb-CPU-inst-1-inst}）测试了表 \ref{tab:supported-instruction} 中所有的算数指令\footnote{在编写测试用例1时未考虑到Mars翻译出来的代码实际上包含了ori指令。而且理论上ori指令与addi指令除了ALUOp信号和ALU执行的算术操作以外并无不同，故后来也未对测试用例1进行补充。}和大部分转发逻辑。在逐时钟周期分析本仿真产生的波形文件的过程中，我纠正了一些线路连接上的错误，如文件 \lstinline|CPU.v| 中的某些 \lstinline|wire| 型变量未连接模块的输出端口，\lstinline|ControlUnit| 的 \lstinline|ALUOp| 输出位数错误等。

\subsubsection{控制指令和冒险}
\label{subsubsec:sim-control-instructions}
本仿真（Listing \ref{code:sim-tb-CPU-inst-2-v}, \ref{code:sim-tb-CPU-inst-2-asm}, \ref{code:sim-tb-CPU-inst-2-inst}）测试了表 \ref{tab:supported-instruction} 中所有的分支指令和跳转指令以及冒险检测单元的功能。在逐时钟周期分析本仿真产生的波形文件的过程中，我补充了先前未注意到的一条转发路径和一个冒险检测逻辑：
\begin{enumerate}
    \item 从 \lstinline|MEMWBRegs| 级间寄存器的 \lstinline|RegWriteData| 转发至 \lstinline|EXMEMRegs| 级间寄存器的 \lstinline|RegRtData| 以解决 \lstinline|lw| 后紧接 \lstinline|sw| 对同一地址先读后写的数据冒险问题。
    \item 若 \lstinline|IFIDRegs| 级间寄存器的 \lstinline|PCSrc| 指示本条指令需要从寄存器中读取跳转地址并跳转（如 \lstinline|jr| 或 \lstinline|jalr| 等），且 \lstinline|IFIDRegs| 级间寄存器的 \lstinline|RegRsAddr| 与 \lstinline|IDEXRegs| 级间寄存器的 \lstinline|RegRtAddr| 或 \lstinline|IDEXRegs| 级间寄存器的 \lstinline|RegRdAddr| 相同，或 \lstinline|EXMEMRegs| 的 \lstinline|MemtoReg| 指示写回寄存器堆的数据由存储器提供，则将ID阶段（及ID之前）的指令阻塞一个周期，等待数据准备完成。本条逻辑解决了j型指令在ID阶段便跳转引起的数据冒险，如 \lstinline|lw| 后立即使用读取到的数据进行跳转的情况。
\end{enumerate}

\subsubsection{整体的稀疏矩阵乘法程序的测试}
本仿真（Listing \ref{code:sim-tb-CPU-inst-3-v}, \ref{code:sim-tb-CPU-inst-3-asm}, \ref{code:sim-tb-CPU-inst-3-inst}）测试了包括BCD7显示在内的整体的稀疏矩阵乘法程序。为方便仿真和观察，将BCD7显示循环次数缩减为16次。由于经过了 \ref{subsubsec:sim-arithmetic-instructions} 节和 \ref{subsubsec:sim-control-instructions}\ 节的测试，在正确编码BCD7显示的内容后，通过观察BCD7的输出波形即简便地验证了算法和CPU设计的正确性。


\subsection{测试稀疏矩阵乘法算法的CPI}
将完整的稀疏矩阵乘法汇编程序中的稀疏矩阵乘法部分代码截取出来（Listing \ref{code:sim-tb-sparse-matmul-alog-asm}），通过Mars仿真器统计指令数为653条（图 \ref{fig:instruction-count}）。需要注意的是Mars仿真器默认数据存储地址与Verilog实现的数据存储器不同，需要在 \lstinline|Memory Configuration| 中选择 \lstinline|Compact, Data at Address 0| 选项。
\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{images/Instruction-Count.png}
    \vspace{-2em}
    \caption{Mars仿真器统计指令数}
    \label{fig:instruction-count}
\end{figure}
同时，使用Mars将该汇编代码的 \lstinline|.text| 部分转换为机器码，进行行为级仿真，从波形文件中读出程序起始于10000ps，结束于7370000ps，时钟周期为10000ps（图 \ref{fig:simulation-time}）。执行这段程序消耗了736个时钟周期，因此稀疏矩阵乘法算法的CPI为
\begin{equation}
    \text{CPI} = \frac{\text{时钟周期数}}{\text{指令数}} = \frac{736}{653} \approx 1.13
\end{equation}
\begin{figure}[H]
    \centering
    \subfigure[起始时间]{
        \includegraphics[width=\linewidth]{images/Instruction-Timing-Start.png}
    }
    \\
    \subfigure[结束时间]{
        \includegraphics[width=\linewidth]{images/Instruction-Timing-End.png}
    }
    \vspace{-1em}
    \caption{稀疏矩阵乘法算法行为级仿真波形图}
    \label{fig:simulation-time}
\end{figure}

\subsection{时序分析和时钟频率}

\subsection{资源占用}
